# 1202 Part2 자바스크립트 기본(ECMAScript)

## 자바스크립트 사용

### Script 태그

- `<script></script>`태그에 인라인 요소로 자바스크립트 코드를 삽입할 경우에는 바로 실행됨, 이를 만나면 스크립트가 실행될 때까지 DOM 생성을 멈춤
- 따라서 `head`에 넣는 것보다 `body`의 끝 부분에 넣는 것이 브라우저 로딩 시간을 줄이는 데에 유리
- `src`를 통해서 외부 파일 혹은 URL을 통해 자바스크립트 코드를 실행할 수 있음, 이때 script 태그의 인라인 요소가 있을 경우에는 인라인 요소는 무시됨
- default type은 `text/javascript`로 정의됨, 속성 필수값은 아님.
- **async 속성** - default는 false/ script 태그에 있는 자바스크립트 코드가 페이지와는 별개로 비동기적으로 실행됨. 즉 브라우저가 페이지를 로딩하는 동안에도 스크립트를 실행할 수 있다면 바로 실행됨, 비동기이므로 복수의 Script 태그가 있을 경우 준비 시간에 따라 코드 순서대로 실행되지 않을 수 있음
- 동적 스크립트는 항상 async처럼 실행됨
- **defer 속성** - 스크립트 태그를 다운로드 도중에도 HTML 파싱이 멈추지 않으며, 실행하는 시점은 페이지 구성이 모두 끝날 때, 문서에 추가된 순으로 실행
- **결론 - async나 defer 모두 자바스크립트를 준비하는 도중에는 DOM 트리 생성을 방해하지 않으나, defer는 DOM 트리 생성이 모두 되었을 때(html 파싱이 모두 된 후 DOMContentLoaded 전) 실행되지만 async는 Dom 트리 생성이 안되었어도 준비가 다 되면 바로 실행됨.**
- 😟DOMContentLoaded 초기 html 문서를 완전히 불러오고 분석했을 때 실행되며, 스타일과 하위 프레임의 로딩은 기다리지 않음
- 😟파싱 브라우저가 문자열을 해석하여 DOM 트리로 만드는 과정

### 변수 정리

- let – 재할당 할 예정인 변수 선언 시 사용. 변수의 값을 변경 가능, 블록 스코프. 재선언 불가능
- const – 변수의 값을 변경 불가. 블록 스코프, 재선언 불가능
- var – 재선언, 재할당 모두 가능하며, ES6 전에 쓰이던 키워드, 호이스팅이 가능하며, 함수 스코프
- 😟불록 스코프 - 블록 바깥에서 접근 불가능(if, while, for의 중괄호 내부)
- 😟함수 스코프 - 함수 바깥에서 접근 불가능(함수의 중괄호 내부)
- 😟호이스팅 - 변수 선언 이전에 참조할 수 있는 현상으로, 변수 선언 이전의 위치에서 접근하면 undefined를 반환함

### 데이터 타입

#### 원시 타입(Primititive Type)

- 객체가 아닌 기본 타입을 의미
- 변수에 해당 타입의 값이 담김
- 복사 시 실제 값이 복사

##### Number type

- 정수, 실수 구분 없으며, 부동소수점 형식을 따름
- NaN 계산이 불가능하며 반환됨
  ```javascript
    const a = 2.88e8
    const b = 1/0
    const c - -1/0
    const d = NaN
  ```

##### String type

- 텍스트 데이터, 16비트 유니코드 문자의 집합
- 탬플릿 리터럴 가능
  ```javascript
    const a = 'pug'
    const b = 'cute'
    const c - `${a}${b}`
  ```

##### Undefined

- 변수의 값이 없음
- 직접 값 할당하지 않으면 자동 할당
- typeof의 결과는 undefined

##### null

- 변수의 값이 없음을 의도적으로 표현할 때 사용
- typeof null은 object (빈객체)

##### Boolean

- 논리적 참 또는 거짓을 나타내는 타입
- undefined와 null, 0, -0, NaN, 빈 문자열은 반드시 거짓

#### 참조 타입(Reference Type)

- 객체 타입
- 변수에 해당 객체의 참조 값이 담김
- 복사 시 참조 값이 복사됨
- 함수, 객체, 배열

##### 함수

- 함수는 값. 따라서 함수도 값처럼 할당, 복사, 선언 가능(함수의 매개 변수가 함수가 될 경우 그 함수는 **Callback 함수(나중에 실행)**).
- “함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재.
- 함수 선언문은 코드 블록이 실행되기도 전에 처리. 따라서 블록 내 어디서든 활용 가능.
- “함수 표현식” 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재.
- 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 생성.

#### 주의

- 😟==(동등 비교 연산자) - 암묵적 타입 변환으로 타입 일치시킨 후 값은 값인지 비교, 객체일 시에는 메모리의 같은 객체를 바라보는지 판별

- 😟===(일치 비교 연산자) - 엄격한 비교(타입과 값 모두 같은지 비교), 자동 형 변환 일어나지 않음

- 😟형변환 - Number(undefined)는 NaN / Number(null)는 0

- 😟**+** - `alert(2+2+"1") == 41`/ `alert( +true) == 1` 단항 연산자 +는 숫자형이 아닌 타입에 쓸 경우, 자동으로 숫자 변환

- 😟`4+5+"px"`== 9px/ `"$"+4+5 == $45`

- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 ‘사전’ 순으로 비교.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행
- null과 undefined는 동등 비교(==) 시 서로 같지만 다른 값과는 같지 않음
  ```javascript
  // null은 비교 가능
  alert(null > 0); // false
  alert(null == 0); // false
  alert(null >= 0); //  true
  //undefined는 비교 불가
  alert(undefined > 0); // false
  alert(undefined < 0); // false
  alert(undefined == 0); // false
  ```
